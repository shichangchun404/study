<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>测试文本选中 并在其位置弹出提示框</title>
  <script src="./html2canvas.min.js"></script>
  <style>
    .canvas-edit-box{
      display: none;
    }
    .botton-box {
      position: fixed;
      z-index: 9999;
      top: 420px;
      left: 1000px;
    }
    .select-widFeedback{
      line-height: 26px;
      height: 28px;
      border: 1px solid #ff6a00;
      padding-left: 8px;
      padding-right: 6px;
      font-size: 0;
      width: 82px;
      box-sizing: border-box;
      cursor: pointer;
      background-color: #fff;
    }
    .select-widFeedback-icon{
      width: 12.1px;
      height: 11.6px;
      display: inline-block;
      background-size: 12.1px 11.6px;
      background-image: url('https://img.alicdn.com/tfs/TB1833Hq9f2gK0jSZFPXXXsopXa-32-32.png');
      vertical-align: sub;
      background-repeat: no-repeat;
    }
    .select-widFeedback-text{
      font-size: 12px;
      color: #ff6a00;
      font-family: PingFangSC-Regular;
      display: inline-block;
      margin-left: 3px;
    }
    .dialogbg{
      position: fixed;
      z-index: 1001;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      opacity: .3;
    }
    .dialog{
      z-index: 1111;
      position: fixed;
      width: 800px;
      height: 300px;
      top: 100px;
      margin-left: 50%;
      left: -400px;
      overflow-x: scroll;
      overflow-y: scroll;
      border: 4px solid #ccc;
    }
    .textarea{
      position: fixed;
      z-index: 1112;
    }
    .hoverRectangle{
      border: solid blue 1px;
      background-color: rgba(192, 80, 77, 0.5) ;
      position: fixed;
      z-index: 1113;
      width: 100px;
      height: 50px;
      top: 100px;
      left: 400px;
    }
    .hide{
      display: none;
    }
  </style>
</head>
<body>
  <div id="content">
    <div>
      <p>
        在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
        从定义中我们提炼出几个关键字：组件、结构、关系；
        组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
        结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
        关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
        从定义中我们提炼出几个关键字：组件、结构、关系；
        组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
        结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
        关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
        从定义中我们提炼出几个关键字：组件、结构、关系；
        组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
        结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
        关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <p>
        架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
      </p>
      <div>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
      </div>
      <div>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          在了解架构本质之前先了解下架构的定义，百度百科对架构的定义：架构又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 ；
          从定义中我们提炼出几个关键字：组件、结构、关系；
          组件：也可以称为软件元素或者是架构要素。可以是子系统、模块、应用服务，取决于不同粒度来看待。
          结构：是架构之后的产出物，不同的软件系统会有不同结构，这些结构是为解决不同场景而设计。
          关系：实现架构组件之间的连接。连接关系可以是JVM内部调用、可以是组件之间、也可以是跨应用的分布式调用、也可以与外系统接口集成调用。
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
        <p>
          架构可以理解为是将软件组件按照一定结构进行连接起来 ；软件组件
        </p>
      </div>
    </div>
    
  </div>

  <div>
    <div class="select-widFeedback hide" style="color:yellow; position: absolute; z-index: 3;" onclick="showDialog()">
      <div class="select-widFeedback-icon"></div>
      <div class="select-widFeedback-text" data-spm-anchor-id="a2c4g.11186623.0.i54.37466d72FONjUY">文档反馈</div>
    </div>
    <div class="canvas-edit-box">
      <div class="dialogbg"></div>
      <div id="dialog" class="dialog"></div>
      <div class="botton-box">
        <button onclick="closeDialog()">取消</button>
        <button onclick="listen4Rectangle()">矩形工具</button>
        <button onclick="listen4Text()">写入文字</button>
        <button onclick="cancel()">撤回</button>
        <button onclick="convertCanvasToImage()">保存提交</button>
      </div>

      <textarea id="textarea" class="textarea hide"></textarea>
      <div id="hoverRectangle" class="hoverRectangle hide"></div>
    </div>
    <div id="imgBox"></div>
  </div>
</body>
<script>
var globalcanvas
var ctx
var imgData = [] // 记录每一步操作内容
var selectObj = document.getElementById('content')
var canvasBox = document.getElementById('dialog')
// var dialogbg = document.getElementById('dialogbg')
var imgBox = document.getElementById('imgBox')
var textarea = document.getElementById('textarea')
var hoverRectangle = document.getElementById('hoverRectangle')
var textareaX = 0
var textareaY = 0
let windowScrollTop = 0
var startPosition
var endPosition
var startClientPoint = {x:0,y:0}
var endClientPoint = {x:0,y:0}
var isShowTextarea = false
var isMouseDown = false // 鼠标在canvas上长安
var fillStyle = 'rgba(192, 80, 77, 0.5)';


listenSelectContent()
listenDocumentClick()
listen4Rectangle()
ListenWindowScroll()

/*
* 监听选择文旦内容
*/
function listenSelectContent(){
  selectObj.onmouseup = function(e){
    var event = window.event || e;
    var position = {'x': e.pageX,'y': e.pageY}
    // startPosition = {'x':e.clientX,'y':e.clientY}
    var target = event.srcElement ? event.srcElement : event.target;
    if (/input|textarea/i.test(target.tagName) && /firefox/i.test(navigator.userAgent)) {
        //Firefox在文本框内选择文字
        var staIndex=target.selectionStart;
        var endIndex=target.selectionEnd;
        if(staIndex!=endIndex){
          var sText=target.value.substring(staIndex,endIndex);
          showTip(sText,target, position);
        }
    } else {
      //获取选中文字
      var sText = document.selection == undefined ? document.getSelection().toString():document.selection.createRange().text;
      if (sText != "") {
        //将参数传入回调函数fn
        showTip(sText, target, position);
      }
    }
  }
  selectObj.onmousedown = function(e){ //1清空dialog内容 2隐藏dialog弹窗
    var endPosition = {'x':e.clientX,'y':e.clientY}
    canvasBox.innerHTML = ''
    closeDialog()
  }
}


/**
 * 矩形工具-监听画布鼠标时间
 */ 
function listen4Rectangle() {
  canvasBox.onmousedown  = function(e){
    isMouseDown = true
    startPosition = {'x': e.offsetX,'y': e.offsetY}
    startClientPoint = {'x': e.clientX,'y': e.clientY}
  }
  // canvasBox.onmouseup = function(e){ // 重绘dom时 该时间失效
  //   isMouseDown = false
  //   hideHoverRectangle()
  //   endPosition = {'x': e.offsetX,'y': e.offsetY}
  //   endClientPoint = {'x': e.clientX,'y': e.clientY}
  //   printRect(startPosition,endPosition)
  // }
  canvasBox.onmousemove = function(e) {
    if (isMouseDown) {
      endPosition = {'x': e.offsetX,'y': e.offsetY}
      endClientPoint = {'x': e.clientX,'y': e.clientY}
      printHoverRectangle(startClientPoint,endClientPoint)
    }
  }
}

/**
 * 点击动态矩形 隐藏本身
 */ 
hoverRectangle.onclick = function(){
  hideHoverRectangle()
  isMouseDown = false
  printRect(startPosition,endPosition)
}

/**
 * 选择插入文字-监听画布鼠标事件
 */
function listen4Text(){
  canvasBox.onmousedown  = function(e){}
  canvasBox.onmouseup = function(e){
    if (isShowTextarea) {
      var text = textarea.value
      fillText(text, textareaX, textareaY)
      setStyle('.textarea{display: none;}')
      textarea.value = ''
      isShowTextarea = false
    } else {
      console.log(e)
      console.log('e.clientX, e.clientY ', e.clientX, e.clientY)
      textareaX = e.offsetX
      textareaY = e.offsetY
      showTextarea(e.clientX,e.clientY)
    }
  }
  canvasBox.onmousemove = function(e) {}
  textarea.focus()
  textarea.select()
}

/**
 * 展示文字输入框
 */
 function showTextarea(x,y) {
  isShowTextarea = true
  var css = `.textarea{left: ${x}px; top: ${y}px;display: block;}`
  setStyle(css)
} 

/**
 * 弹出框tip
 */
function showTip(txt,target,position){
  console.log('showTip position', position)
  getCanvasFromHtml()
  var css = `.select-widFeedback{left: ${position.x}px; top: ${position.y}px;display: block;}`
  setStyle(css)
}


/**
 * html2canvas 生成页面截图
 */
function getCanvasFromHtml(){
  html2canvas(document.body).then(function(canvas) {
    globalcanvas = canvas
    canvasBox.appendChild(canvas)
    ctx = globalcanvas.getContext("2d");
    canvas_copy()
  });
}

/**
 * 监听页面点击 取消tip弹窗
 */ 
function listenDocumentClick(){
  document.onclick=function(e){
    var event = window.event || e;
    var target = event.srcElement ? event.srcElement : event.target;
    var sText = ''
    if (/input|textarea/i.test(target.tagName) && /firefox/i.test(navigator.userAgent)) {
      //Firefox在文本框内选择文字
      var staIndex=target.selectionStart;
      var endIndex=target.selectionEnd;
      if(staIndex!=endIndex){
        sText=target.value.substring(staIndex,endIndex);
      }
    } else {
      //获取选中文字
      sText = document.selection == undefined ? document.getSelection().toString():document.selection.createRange().text;
    }
    if (sText) {
      return
    }
    setStyle(`.select-widFeedback{display: none;}`)
  }
}

/**
 * canvas转图片
 */
function convertCanvasToImage(canvas) {
	var image = new Image();
	image.src = globalcanvas.toDataURL("image/png");
  console.log('image ====', image)
  imgBox.appendChild(image)
}

/**
 *  设置style
 */
function setStyle(css){
  var style = document.createElement("style");
  style.type = "text/css";
  try{
    　style.appendChild(document.createTextNode(css));
  }catch(ex){
  　　style.styleSheet.cssText = css; //针对IE
  }
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(style);
}



/**
 * 绘制矩形区域
 */
function printRect(start,end){
  ctx.fillStyle = fillStyle;
  ctx.fillRect(start.x, start.y-windowScrollTop, end.x-start.x, end.y-start.y);
  canvas_copy()
}

/**
 * 动态矩形
 */ 
function printHoverRectangle(start,end){ 
  console.log('start,end ', start,end)
  var style = `.hoverRectangle{display: block;left: ${start.x}px;top: ${start.y}px;width: ${end.x-start.x}px;height: ${end.y-start.y}px;}`
  setStyle(style)
}
function hideHoverRectangle(){
  var style = `.hoverRectangle{display: none;left: 0px;top: 0px;width: 0px;height:0px;}`
  setStyle(style)
}


/**
 * 绘制文字
 */ 
function fillText(text,x,y){
  ctx.font = 'bold 16px arial';
  ctx.fillStyle = 'red'
  ctx.fillText(text, x, y-windowScrollTop);
  canvas_copy()
}

/**
 * 将每一步记录复制存储起来
 */
function canvas_copy(){
  var width = ctx.canvas.width;
  var height = ctx.canvas.height;
  imgData.push(ctx.getImageData(0, 0, width, height))
}

/**
 * 撤回 取出imgData记录的上一张
 */ 
function cancel(){
  console.log(imgData)
  if (imgData.length>1) {
    imgData.pop()
    ctx.putImageData(imgData[imgData.length-1],0,0);
  } else {
    console.log('已经是第一步了')
  }
}

function ListenWindowScroll() {
  window.addEventListener("scroll", windowScroll);//监听页面滚动
  function windowScroll(e) {
    windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
  }    
}

/**
 * 展示蒙层 并禁止body滚动 否则canvas绘制定位有问题
 */ 
function showDialog() {
  setStyle(`.canvas-edit-box{display: block;}`)
  document.body.style.overflow='hidden'
}

/**
 * 取消蒙层 放开body滚动
 */ 
function closeDialog () {
  setStyle(`.canvas-edit-box{display: none;}`)
  document.body.style.overflow='auto'
}

</script>
</html>